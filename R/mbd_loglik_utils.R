#' @title are_these_parameters_wrong
#' @description check parameters consistency
#' @inheritParams default_params_doc
#' @author Giovanni Laudanno
#' @export
are_these_parameters_wrong <- function(
  brts,
  pars,
  safety_threshold,
  n_0
) {

  lambda <- pars[1]
  mu <- pars[2]
  nu <- pars[3]
  q <- pars[4]

  # checks
  if (length(pars) != 4) {
    stop("'pars' must have a length of four")
  }
  if (any(is.nan(pars))) {
    stop("'pars' cannot contain NaNs")
  }
  if (!check_brts_consistency(brts = brts, n_0 = n_0)) {
    stop("these branching times cannot be generated by a mbd process")
  }

  out <- (any(is.infinite(pars))) ||
    (lambda < 0) ||
    (mu < 0) ||
    (nu < 0) ||
    (q < 0) ||
    (q > 1) ||
    (q < 0 + safety_threshold) ||
    (q > 1 - safety_threshold)

}

#' Function to build a matrix, used in creating the A and B operators.
#' It produces the structure
#'  q ^ (m - n) * (1 - q) ^ (k + 2 * n-m) *
#'  sum_j 2 ^ j choose(k, j) * choose(n, m - n - j)
#' @inheritParams default_params_doc
#' @examples
#'   m <- hyper_a_hanno(n_species = 2, k = 2, q = 0.1)
#'   testthat::expect_equal(m[1, 1], 0.81)
#'   testthat::expect_equal(m[1, 2], 0.00)
#'   testthat::expect_equal(m[1, 3], 0.00)
#'   testthat::expect_equal(m[2, 1], 0.36)
#'   testthat::expect_equal(m[2, 2], 0.729)
#'   testthat::expect_equal(m[2, 3], 0.00)
#'   testthat::expect_equal(m[3, 1], 0.04)
#'   testthat::expect_equal(m[3, 2], 0.405)
#'   testthat::expect_equal(m[3, 3], 0.6561)
#' @noRd
#' @author Hanno Hildenbrand, adapted by Richel J.C. Bilderbeek
hyper_a_hanno <- function(
  n_species,
  k,
  q
) {
  if (n_species > 46340) {
    stop("'n_species' must be below 46340. ",
         "Cannot allocate matrix with 2^31 elements")
  }
  # HG function: fast O(N), updated after Moulis meeting
  j <- 0:k
  a_1 <- (1 - q) ^ (k) * choose(k, j) * (2)^j
  n_species <- n_species + 1
  matrix_a <- diag(a_1[1], nrow = n_species + 2, ncol = n_species + 2)
  matrix_a[1:(k + 1), 1] <- a_1
  for (dst in 2:n_species) {
    src <- dst - 1
    s <- src:min(n_species, 2 * src + k - 1)
    matrix_a[s + 2, dst] <- matrix_a[s, src] + matrix_a[s + 1, src]
    m <- s - 1
    n <- src - 1
    matrix_a[s, src] <- matrix_a[s, src] * q ^ (m - n) * (1 - q) ^ (2 * n - m)
  }
  matrix_a[n_species, n_species] <- matrix_a[n_species, n_species] *
    (1 - q) ^ (n_species - 1)
  matrix_a[1:n_species, 1:n_species]
}

#' @title A matrix
#' @description Creates the A matrix,
#' used for likelihood integration between branching times.
#' @inheritParams default_params_doc
#' @details This is not to be called by the user.
#' @author Giovanni Laudanno
#' @export
create_a <- function(pars, k, lx, matrix_builder = hyper_a_hanno) {
  lambda <- pars[1]
  mu <- pars[2]
  nu <- pars[3]
  q <- pars[4]

  testit::assert(lx < 2^31)
  nvec <- 0:lx

  m <- nu * matrix_builder(n_species = lx, k = k, q = q)
  diag(m) <- (-nu) * (1 - (1 - q) ^ (k + nvec)) - (lambda + mu) * (k + nvec)
  m[row(m) == col(m) - 1] <- mu * nvec[2:(lx + 1)]
  m[row(m) == col(m) + 1] <- m[row(m) == col(m) + 1] +
    lambda * (nvec[1:(lx)] + 2 * k)
  m[length(nvec), length(nvec)] <- (-mu) * (k + nvec[length(nvec)]) +
    (-nu) * (1 - (1 - q) ^ (k + nvec[length(nvec)]))

  m
}

#' @title B matrix
#' @description Creates the B matrix,
#' used to modify the likelihood on branching times.
#' @inheritParams default_params_doc
#' @details This is not to be called by the user.
#' @author Giovanni Laudanno
#' @export
create_b <- function(pars, k, b, lx, matrix_builder = hyper_a_hanno) {
  if (b > k) {
    stop("you can't have more births than species present in the phylogeny")  # nolint
  }

  lambda <- pars[1]
  nu <- pars[3]
  q <- pars[4]

  k2 <- k - b
  m <- matrix_builder(n_species = lx, k = k2, q = q)

  lambda * k * diag(lx + 1) * (b == 1) + nu * choose(k, b) * (q^b) * m
}

#' The A operator is given by the integration of a set of differential equations
#' between two consecutive nodes. So, defined the set in the time interval
#' [t_{i-1}, t_i], where k species are present in the phylogeny, as:
#'
#' d
#' --Q^k_m(t) = SUM_n(M^k_m,n * Q^k_n(t)
#' dt
#'
#' where m, n, label the amount of unseen species in the phylogeny,
#' A is thus defined as:
#'
#' A(t_i - t_{i-1}) = exp(M(t_k - t_{k-1})
#' @inheritParams default_params_doc
#' @author Giovanni Laudanno
#' @noRd
a_operator <- function(
  q_vector,
  transition_matrix,
  time_interval,
  precision = 50L,
  abstol = 1e-16,
  reltol = 1e-10,
  methode = "expo"
) {
  precision_limit <- 2000
  precision_step1 <- 40
  precision_step2 <- 50
  max_repetitions <- 10
  result <- rep(-1, length(q_vector))
  bad_result <- 0

  testit::assert(methode != "sexpm")
  if (methode == "expo") {
    result_nan <- result_negative <- 1
    repetition <- 1
    while ((result_nan == 1 | result_negative == 1) &
           repetition < max_repetitions) {
      result <- try(expoRkit::expv(v = q_vector,
                                   x = transition_matrix,
                                   t = time_interval,
                                   m = precision),
                    silent = TRUE
      )

      result_nan <- (any(!is.numeric(result)) || any(is.nan(result)))
      if (result_nan) {
        precision <- precision - precision_step1
      } else {
        result_negative <- (any(result < 0))
        if (result_negative) {
          precision <- precision + precision_step2
          if (precision > precision_limit) {
            break
          }
        }
      }
      repetition <- repetition + 1
    }
  }

  bad_result <- (any(!is.numeric(result)) || any(is.nan(result)))
  if (!bad_result) {
    bad_result <- (any(result < 0))
  }

  if (methode == "lsoda" | bad_result) {
    times <- c(0, time_interval)
    ode_matrix <- transition_matrix
    R.utils::withTimeout(
      result <- deSolve::ode(
        y = q_vector,
        times = times,
        func = mbd_loglik_rhs,
        parms = ode_matrix,
        atol = abstol,
        rtol = reltol
      )[2, -1],
      timeout = 1001
    )
  }

  result
}

#' @title Builds the right hand side of the ODE set for multiple birth model
#' @description Builds the right hand side of the ODE set
#' for multiple birth model
#' @inheritParams default_params_doc
#' @details This is not to be called by the user.
#' @author Giovanni Laudanno
#' @export
mbd_loglik_rhs <- function(t, x, params) {
  with(as.list(x), {
    starting_vector <- x
    transition_matrix <- params
    dx <- rep(0, length(starting_vector))
    dx <- drop(transition_matrix %*% starting_vector)
    out <- (dx)
    names(out) <- names(x)
    return(list(out))
  })
}

#' @title Test consistency of branching times
#' @description Test if the given branching times
#' can actually be generated by a MBD process.
#' In any moment you CANNOT have more births than number of species.
#' @inheritParams default_params_doc
#' @return TRUE or FALSE.
#' @author Giovanni Laudanno
#' @export
check_brts_consistency <- function(brts, n_0) {
  births <- brts2time_intervals_and_births(brts)$births # nolint internal function
  kvec <- n_0 + cumsum(c(0, births))
  kvec
  all(births <= kvec[-length(kvec)])
}

#' Converts branching times to 'time intervals between branching times'
#'   and 'birth at nodes' vectors
#' @inheritParams default_params_doc
#' @noRd
brts2time_intervals_and_births <- function(brts) {

  branching_times <- unlist(unname(sort(abs(brts), decreasing = TRUE)))
  unique_branching_times <- unique(branching_times)
  time_intervals <- c(0, -diff(c(unique_branching_times, 0)))
  multiple_births_coords <- duplicated(branching_times)
  multiple_branching_times <- unique(branching_times[multiple_births_coords])
  births <- c(
    0,
    rev(c(
      unname(table(branching_times))
    ))[-1],
    0
  )

  testit::assert(length(births) == length(time_intervals))
  testit::assert(
    rev(cumsum(rev(time_intervals)))[-1] == unique_branching_times
  )
  testit::assert(
    all(unique_branching_times[births > 1] == multiple_branching_times)
  )
  testit::assert(all(multiple_branching_times %in% branching_times))
  for (i in seq_along(multiple_branching_times)) {
    testit::assert(
      sum(multiple_branching_times[i] == branching_times) > 1
    )
  }

  list(
    time_intervals = time_intervals,
    births = births
  )
}

#' Checks for NA, NaN or negative components in a vector (usually used for q_t)
#' @inheritParams default_params_doc
#' @param v a vector
#' @param display_output If TRUE it prints the flags
#' @noRd
negatives_correction <- function(v, pars, display_output = 0) {
  problems <- 0
  if (any(is.na(v))) {
    problems <- 1
    na_components <- which(is.na(v) & !is.nan(v))
    nan_components <- which(is.nan(v))
    if (display_output == 1) {
      cat("There are non-numeric components for par values:", pars, "\n")
      if (length(na_components) > 0) {
        cat("NA component are:", na_components)
      }
      if (length(nan_components) > 0) {
        cat("NaN component are:", nan_components)
      }
    }
  }

  if (any(v < 0) && problems == 0) {
    v[v < 0 & (abs(v) / abs(max(v))) < 1e-10] <- 0
  }
  v
}

#' Get the names of the parameters used in the MBD model
#' @author Richel J.C. Bilderbeek
#' @export
get_mbd_param_names <- function() {
  c("lambda", "mu", "nu", "q")
}

#' Count the number of multiple speciation events
#' @inheritParams default_params_doc
#' @author Giovanni Laudanno
#' @export
mbd_count_n_spec_events <- function(brts) {
  births <- mbd:::brts2time_intervals_and_births(brts)$births
  sum(births > 1)
}
