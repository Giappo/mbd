---
title: "MBD: The Multiple Birth-Death model"
author: "Giovanni Laudanno"
header-includes:
   - \usepackage{bbm}
date: "`r Sys.Date()`"
output:
  bookdown::pdf_document2:
    fig_caption: yes
    number_sections: true
bibliography: bibliography.bib
vignette: >
  %\VignetteIndexEntry{mbd derivation}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

Install the package:

```{r}
while (!require(devtools)) {install.packages("devtools")};
devtools::install_github("Giappo/mbd@debug");
library(mbd);
```

# The theory

## The process

Mbd stands for Multiple-Birth-Death. It is a model that includes the possibility
of the occurrance of multiple simultaneous speciations at any given time.
The process allows 3 possible events to occurr:

* single speciation, with rate $\lambda$;
* extinction, with rate $\mu$;
* multiple speciation, with rate $\nu$. Then, if it occurs, each of the species present has probability $q$ to speciate;

Parameters $\lambda$ and $\mu$ reproduce the effect of the standard birth-death
model. The novelty comes from the possibility of multiple speciation.
However all the species present at a given time are not all equal. Part of them
are in fact visible in the reconstructed tree and part are not, because they will go extinct before the
present. We will label these as $k$- and $m$-species, respectively.
Having two different pools, we will consider separately the speciations coming
from each pool, according to the simple binomial law mentioned before.

### Transition from the $m$-pool

The $m$-pool can only produce new species in the $m$-pool, as if visible species
were produced this will contradict the definition itself of invisible species.

The probability $M$ of multiple speciation from the $m$-pool leading to the change
of state $(m,k) \rightarrow (m + i, k)$ is

$$
M^{k,k}_{m,m + i} = \binom{m}{i} q ^ i (1 - q) ^ {m - i}
$$

### Transition from the $k$-pool

If the multiple speciation occurs starting from the $k$-pool things are more complex,
as this can change the number of species in both pools.

The probability $K$ of multiple speciation from the $k$-pool leading to the change
of state $(m,k) \rightarrow (m + i, k + b)$ is

$$
K^{k, k + b}_{m, m + j} = 2 ^ j \binom{k}{b} \binom{k - b}{j} q ^ {b + j} (1 - q) ^ {k - b - j}
$$

Here the factor $2 ^ j$ comes from the fact that for each of the $j$ speciations
from the $k$-pool to the $m$-pool has two different ways to realize. In fact, 
having two species, say 1 and 2, in the process of reconstructing
the tree we could interpret 1 as the visible and 2 as the invisible or the other
way around. Having $j$ new species the number of possibilities becomes $2 ^ j$.
This factor arises for the same reason of the factor $2k$ in the lambda term
of the original Q-equation in @etienne2012diversity (see also Q-equation below).

### Full Transition from both pools

If we want to consider the full process we have to combine the two probabilities
$K^{k, k + b}_{m, m + j}$ and $M^{k,k}_{m, m + i}$.

The probability $P$ of multiple speciation from both pools leading to the change
of state $(m,k) \rightarrow (m + i + j, k + b)$ is the convolution of the two
terms:

$$
\begin{aligned}
N^{k, k + b}_{m, m + a} & = [K^{k, k + b}_{m, m + j} * M^{k,k}_{m, m + i}]^{k, k + b}_{m, m + a} \\
& = \binom{k}{b} q ^ b (1 - q) ^ {k + m - b}
\sum_j 2 ^ j \binom{k - b}{j} \binom{m - a} {a - j} q^a (1 - q) ^{-2a}
(\#eq:ndefinition)
\end{aligned}
$$

where $a = i + j$. Such matrix can be created using the R function from the
mbd package:

```{r}
lambda <- 0.2; mu <- 0.15; nu <- 1; q <- 0.1; # mbd parameters
pars <- c(lambda, mu, nu, q)
lx <- 7 # matrix dimension
k <- 2 # k-species
b <- 1 # births
n_matrix <- mbd:::create_n(pars = pars, k = k, b = b, lx = lx)
n_matrix
```

## The likelihood

Mbd is a likelihood-based model. The structure of the likelihood is taken from 
@etienne2012diversity. Such framework is built around the core function 
$Q_{m}^{k}(t)$ which represents the probability to have, at the time $t$, $k$
species visible in the phylogeny as well as $m$ additional species that will
go extinct before the present time. In the following we will refer to visible
species always with the letter $k$ and to unseen species with indexes $m$
or $n$.
In this context the likelihood is defined as

$$
L = \frac{Q_{m = 0}^{k = k_{p}}(t_{p})}{P_c}
$$

where $t_p$ is the present time and $k_p$ is the number of visible species at
the present, namely the number of tips. $P_c$ stands for a possible conditioning
probability.
To obtain the vector $\mathbf{Q}^k(t)$ at the present one must integrate it from
the crown (or stem) age to the present. The starting vector at the base of the
tree is

$$
Q_{m}^{k_{1}}(t_{1}) = \delta_{m,0}
$$

Given the vector of the phylogeny's branching times
$\mathbf{t} = (t_1, \dots, t_p)$, the integration scheme can be
summarized by the following

$$
 \mathbf{Q}^{k_p}(t_p) = A^{k_p}(t_{k_p-1},t_p)\, B^{k_p-1,k_p}\,
    A^{k_p-1}(t_{k_p-2},t_{k_p-1}) \ldots \notag \\
 \qquad A^{4}(t_3,t_4)\,B^{3,4}\,A^{3}(t_2,t_3)\,
    B^{2,3}\, A^{2}(t_1,t_2)\, \mathbf{Q}^2(t_1)
$$

where $B^{k - 1, k}$ and $A^k$ are matrices that take into account how
the $\mathbf{Q}^k$ has to be modified, respectively, on branching times and in
the time intervals between consecutive branching times. Note that on the
elements $A$, $B$ and $\mathbf{Q}$ the subscript is not to be intended as a 
power, but it is just an index to keep track of the k-species.

### A operator

The A operator is given by the integration of a set of differential equations
between two consecutive nodes. So, defined the set in the time interval
$[t_{i-1}, t_i]$, where k species are present in the phylogeny, as:

$$
\frac{d}{dt}Q^k_m(t) = \Sigma_n T^{k,k}_{m,n} \cdot Q^k_n(t)
$$

where m, n, label the amount of unseen species in the phylogeny,
A is thus defined as:

$$
A(t_i - t_{i-1}) = e^{T^{k,k}(t_k - t_{k-1})}
$$

And the formal solution in $t = t_{i}$ from initial conditions at $t_{i - 1}$ is

$$
Q^k_m(t_{i}) = A_{m,n}(t_i - t_{i-1}) Q^k_n(t_{i - 1})
$$

#### Transition matrix and Q equation

The matrix $T^k$ summarizes the system of ordinary differential equations (ODE)
used to evolve in time the vector $\mathbf{Q}^k$ in a given time interval with
a fixed amount of k-species. The ODE system is the following

$$
\begin{aligned}
\frac{d Q^k_m(t)}{dt} & = 
\lambda (m + 2k - 1) Q^k_{m - 1}(t) +
\mu (m + 1) Q^k_{m + 1}(t) \\
& + \nu (1 - q) ^ {k + m} 
\sum_{a}
\sum_{j} 2 ^ {j} \binom{k}{j} \binom{m - a}{a - j} q ^ {a} (1 - q) ^ {- 2a}
Q^k_{m - a}(t) \\
& - (\lambda + \mu) (m + k) Q^k_{m}(t)
- \nu (1 - (1 - q) ^ {m + k}) Q^k_{m}(t)
\end{aligned}
$$
Here the two $\nu$ terms are obtained following the reasoning explained in the 
previous section, when the multiple speciation mechanism has been described.

#### Q equation: matrix form

The way the ODE set is implemented in the mbd package is by using matrices.
It is possible to decompose the transition matrix $T^k$ in the following way

$$
\begin{aligned}
T^{k,k}_{m,n} & =
\mu \delta_{m, n - 1} (m + 1)
\qquad & \text{if} \qquad
m < n
\\
T^{k,k}_{m,n} & =
- (\lambda + \mu) (k + m)
- \nu (1 - (1 - q) ^ {k + m}) 
\qquad & \text{if} \qquad
m = n
\\
T^{k,k}_{m,n} & =
\lambda \delta_{m, n + 1} (m + 2k - 1) +
\nu N^{k,k}_{m,n}
\qquad & \text{if} \qquad
m > n
\end{aligned}
$$

The matrix $N^{k,k}$ is given by \@ref(eq:ndefinition).

#### A operator: Implementation

The transition matrix can be created using

```{r}
lambda <- 0.2; mu <- 0.15; nu <- 1; q <- 0.1;
pars <- c(lambda, mu, nu, q)
lx <- 9
k <- 2
transition_matrix <- mbd:::create_a(pars = pars, lx = lx, k = k)
transition_matrix
```

We can verify that the entries respect our definition:

```{r}
# m < n
for (n in 1:lx) {
  for (m in 0:(n - 1)) {
    testthat::expect_equal(
      (m == n - 1) * mu * (m + 1),
      transition_matrix[m + 1, n + 1]
    )
  }
}
# m = n
m <- 0:lx
testthat::expect_equal(
  diag(transition_matrix),
  -(lambda + mu) * (m + k) - nu * (1 - (1 - q) ^ (m + k))
)
# m > n
for (m in 1:lx) {
  for (n in 0:(m - 1)) {
    a <- m - n
    j <- 0:min(m - n, k)
    entry_m_n <- 
      (m - n == 1) * lambda * (m + 2 * k - 1) +
      nu *
      (1 - q) ^ (k + m) *
      q ^ a * 
      (1 - q) ^ (-2 * a) *
      sum(
        2 ^ j * choose(k, j) * choose(m - a, a - j)
      )
    testthat::expect_equal(
      entry_m_n,
      transition_matrix[m + 1, n + 1]
    )
  }
}
```

Then it is possible to use this transition matrix to evolve $Q^k(t)$

```{r}
t_1 <- 0
t_2 <- 2
q_1 <- c(1, rep(0, lx))
q_2 <- mbd:::a_operator(
  q_vector = q_1,
  transition_matrix = transition_matrix,
  time_interval = t_2 - t_1
)
print(paste(c("Vector Q at time t_1 is:", q_1), collapse = " "))
print(paste(c("Vector Q at time t_2 is:", signif(q_2, digits = 2)), collapse = " "))
plot(q_2, ylab = "Q(t_2)", xlab = "m")
```

### B operator

The $B^{k, k + b}$ operator, acting on the branching times, is built in a similar way.
The main difference is that $b$ births are given and are observable on the tree.
If $b = 1$ the transition can be explained by both speciation processes. They 
are, though, mutually exclusive, as each of them has a probability proportional
to $dt$ and each term of higher order is negligible.

$$
B^{k,k + b}_{m,n} = \lambda k \delta_{m,n} \delta_{b,1} + \nu N^{k,k + b}_{m,n}
$$

#### B operator: Implementation

The $B^{k, k + b}$ matrix can be created using

```{r}
b <- 1
b_matrix <- mbd:::create_b(pars = pars, lx = lx, k = k, b = b)
b_matrix
```

We can verify that the entries respect our definition:

```{r}
# m < n
testthat::expect_true(
  all(b_matrix[upper.tri(b_matrix, diag = FALSE)] == 0)
)
# m >= n
for (m in 0:lx) {
  for (n in 0:m) {
    a <- m - n
    j <- 0:min(m - n, k)
    entry_m_n <- 
      (m == n) * (b == 1) * lambda * k +
      nu *
      choose(k, b) * q ^ b *
      (1 - q) ^ (k - b + m) *
      q ^ a * 
      (1 - q) ^ (-2 * a) *
      sum(
        2 ^ j * choose(k - b, j) * choose(m - a, a - j)
      )
    testthat::expect_equal(
      entry_m_n,
      b_matrix[m + 1, n + 1]
    )
  }
}
```

# Implementation problems

The goal of this section is to expose issues in the mbd likelihood computation
due to weird probabilities.

## Negative Probabilities in the Q-vector

First we set the parameter that expose the problem.

```{r}
brts <- c(10, 9, 7, 6, 5) # branching times
pars <- c(2, 0.05, 1.00, 0.1) # mbd parameters = c(lambda, mu, nu, q)
n_0 <- 2 # starting species
cond <- 1 # conditioning? 1 is yes, 0 is no.
tips_interval <- c(n_0 * (cond > 0), Inf) # how many tips are allowed in tree?
lx <- 200 # dimension of the transition matrix
abstol <- 1e-16 # absolute tolerance for ode
reltol <- 1e-10 # relative tolerance for ode
```

Then we try to calculate the likelihood with a given \link{ode} method. In this
first try we use "ode45".

```{r}
methode <- "ode45" # ode method
loglik <- mbd_loglik(
  pars = pars,
  brts = brts,
  n_0 = n_0,
  cond = cond,
  tips_interval = tips_interval,
  lx = lx,
  methode = methode,
  abstol = abstol,
  reltol = reltol
)
```

The same problem appears if we use "lsodes":

```{r}
methode <- "lsodes" # ode method
loglik <- mbd_loglik(
  pars = pars,
  brts = brts,
  n_0 = n_0,
  cond = cond,
  tips_interval = tips_interval,
  lx = lx,
  methode = methode,
  abstol = abstol,
  reltol = reltol
)
```

And also with "lsoda":

```{r}
methode <- "lsoda" # ode method
loglik <- mbd_loglik(
  pars = pars,
  brts = brts,
  n_0 = n_0,
  cond = cond,
  tips_interval = tips_interval,
  lx = lx,
  methode = methode,
  abstol = abstol,
  reltol = reltol
)
```

## Conditional probabilities > 1

For some parameter settings conditional probabilities exceed the unity. This is
clearly a bug.
We pick some test parameters to expose the bug:

```{r}
brts <- c(10, 9, 7, 6, 5)
pars <- c(0.0204942104, 0.0001333249, 1.5728643216, 0.0787076385)
n_0 <- 2
cond <- 1
tips_interval <- c(n_0 * (cond > 0), Inf)
lx <- 200
methode <- "lsodes"
abstol <- 1e-16
reltol <- 1e-10
```

Then we calculate the conditional probability. According to the model this is
done by integrating across a single time interval spanning from the crown age
and the present.

```{r}
pc <- mbd:::calculate_conditional_prob_debug(
  brts = brts,
  pars = pars,
  cond = cond,
  n_0 = n_0,
  lx = lx,
  tips_interval = tips_interval,
  methode = methode,
  abstol = abstol,
  reltol = reltol
)
```

The problem still occurs if we augment the tolerance of the integrator
(abstol and reltol), if we change the integrator ("ode45" or "lsoda") or if we
increase the size of the transition matrix (lx = 1000).

```{r}
pc <- mbd:::calculate_conditional_prob_debug(
  brts = brts,
  pars = pars,
  cond = cond,
  n_0 = n_0,
  lx = 1000,
  tips_interval = tips_interval,
  methode = methode,
  abstol = abstol * 10 ^ -3,
  reltol = reltol * 10 ^ -3
)
pc <- mbd:::calculate_conditional_prob_debug(
  brts = brts,
  pars = pars,
  cond = cond,
  n_0 = n_0,
  lx = lx,
  tips_interval = tips_interval,
  methode = "ode45",
  abstol = abstol,
  reltol = reltol
)
pc <- mbd:::calculate_conditional_prob_debug(
  brts = brts,
  pars = pars,
  cond = cond,
  n_0 = n_0,
  lx = lx,
  tips_interval = tips_interval,
  methode = "lsoda",
  abstol = abstol,
  reltol = reltol
)
```

It is also possible to break down the total conditioning probability in all its
components. The vector q_f is the result of the integration and the m-th
component represents the probability to have m - 1 additional species (besides
the original n_0 ones) at the present. The conditional probability is obtained
by summing all of them, effectively accounting for all the possible ways of
keeping the starting n_0 species until the present time, marginalizing the
distribution over all the possible additional species.

```{r}
out <- mbd:::mbd_calculate_q_vector(
  pars = pars,
  brts = brts[1],
  n_0 = n_0,
  lx = lx,
  methode = methode,
  abstol = abstol,
  reltol = reltol
)
sum(out$q_f)
out$q_t
```