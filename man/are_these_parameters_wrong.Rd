% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mbd_loglik_utils.R
\name{are_these_parameters_wrong}
\alias{are_these_parameters_wrong}
\title{are_these_parameters_wrong}
\usage{
are_these_parameters_wrong(brts, pars, safety_threshold, n_0)
}
\arguments{
\item{brts}{A set of branching times of a phylogeny.}

\item{pars}{vector of parameters:
\itemize{
  \item pars[1] is lambda, the sympatric speciation rate;
  \item pars[2] is mu, the extinction rate;
  \item pars[3] is nu, the multiple allopatric speciation trigger rate;
  \item pars[4] is q, the single-lineage speciation probability;
}}

\item{safety_threshold}{adds a threshold for the evaluation of q. This is due
because you never want \code{q} to actually be equal to zero or one.}

\item{n_0}{the number of lineages at time equals zero.}
}
\value{
the answer to the question: are these parameters wrong?
}
\description{
check parameters consistency
}
\details{
#' @export
myTryCatch <- function(expr) {
  warn <- err <- NULL
  value <- withCallingHandlers(
    tryCatch(expr, error = function(e) {
      err <<- e
      NULL
    }), warning = function(w) {
      warn <<- w
      invokeRestart("muffleWarning")
    })
  list(
    value = value,
    warning = warn,
    error = err
  )
}

#' The A operator is given by the integration of a set of differential equations
#' between two consecutive nodes. So, defined the set in the time interval
#' [t_{i-1}, t_i], where k species are present in the phylogeny, as:
#'
#' d
#' --Q^k_m(t) = SUM_n(M^k_m,n * Q^k_n(t)
#' dt
#'
#' where m, n, label the amount of unseen species in the phylogeny,
#' A is thus defined as:
#'
#' A(t_i - t_{i-1}) = exp(M(t_k - t_{k-1})
#' @inheritParams default_params_doc
#' @author Giovanni Laudanno
#' @noRd
a_operator <- function(
  q_vector,
  transition_matrix,
  time_interval,
  precision = 50L,
  abstol = 1e-16,
  reltol = 1e-10,
  methode = "lsodes"
) {
  out <- list(
    value = NULL,
    warning = 1,
    error = 1
  )
  while (!is.null(out$warning) || !is.null(out$error)) {
    times <- c(0, time_interval)
    ode_matrix <- transition_matrix
    R.utils::withTimeout(
      out <- myTryCatch(deSolve::ode(
        y = q_vector,
        times = times,
        func = mbd_loglik_rhs,
        parms = ode_matrix,
        atol = abstol,
        rtol = reltol,
        method = methode
      )[2, -1]),
      timeout = 1001
    )
  }
  out$warning
  out$error
  result <- out$value
  result
}
}
\author{
Giovanni Laudanno
}
