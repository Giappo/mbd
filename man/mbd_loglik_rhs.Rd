% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mbd_loglik_utils.R
\name{mbd_loglik_rhs}
\alias{mbd_loglik_rhs}
\title{Internal mbd function}
\usage{
mbd_loglik_rhs(t, x, pars)
}
\arguments{
\item{t}{something}

\item{x}{something}

\item{pars}{vector of parameters:
\itemize{
  \item pars[1] is the multiple speciation trigger rate;
  \item pars[2] is the extinction rate;
  \item pars[3] is the single-lineage speciation probability.
}
or
\itemize{
  \item pars[1] is lambda, the sympatric speciation rate;
  \item pars[2] is mu, the extinction rate;
  \item pars[3] is nu, the multiple allopatric speciation trigger rate;
  \item pars[4] is q, the single-lineage speciation probability.
}}
}
\description{
Internal mbd function.
}
\details{
#' @title Internal mbd function
#' @description Internal mbd function.
#' @details This is not to be called by the user.
#' @export
A_operator_old <- function(Q, transition_matrix, time_interval, precision = 50L,
                       a_abstol = 1e-16, a_reltol = 1e-10, methode = "expo"){

precision_limit <- 3000

if (methode == "sexpm")
  {
    exp_matrix <- rsexpm:::sexpm(transition_matrix * time_interval)
    result     <- exp_matrix %*% Q
  }else if (methode == "expo")
  {
    result <- try(expoRkit::expv(v = Q, x = transition_matrix, t = time_interval, m = precision), silent = T)
    while ( ( any(!is.numeric(result)) || any(is.nan(result)) ) && precision < precision_limit )
    {
      precision <- precision + 200
      result <- try(expoRkit::expv(v = Q, x = transition_matrix, t = time_interval, m = precision), silent = T)}
    if (!any(is.nan(result)))
    {
      while (any(result < 0) && precision < precision_limit)
      {
        precision <- precision + 200
        result <- try(expoRkit::expv(v = Q, x = transition_matrix, t = time_interval, m = precision), silent = T)
      }
    }
  }else if (methode=="lsoda")
  {
    times <- c(0, time_interval)
    ode_matrix <- transition_matrix
    # result<-deSolve::ode(y = Q, times = times, func = mbd_loglik_rhs, parms = ode_matrix,atol=a_abstol,rtol=a_reltol)[2,-1]
    R.utils::withTimeout(result <- deSolve::ode(y = Q, times = times, func = mbd_loglik_rhs, parms = ode_matrix,atol=a_abstol,rtol=a_reltol)[2,-1], timeout = 1000)
  }

if (any(!is.numeric(result)) || any(is.nan(result))) #sometimes expoRkit gives weird negative values. In this case perform standard lsoda integration.
  {
    times <- c(0, time_interval)
    ode_matrix <- transition_matrix
    # result<-deSolve::ode(y = Q, times = times, func = mbd_loglik_rhs, parms = ode_matrix,atol=a_abstol,rtol=a_reltol)[2,-1]
    R.utils::withTimeout(result <- deSolve::ode(y = Q, times = times, func = mbd_loglik_rhs, parms = ode_matrix,atol=a_abstol,rtol=a_reltol)[2,-1], timeout = 1000)
  }
  else if (any(result < 0)) #sometimes expoRkit gives weird negative values. In this case perform standard lsoda integration.
  {
    times <- c(0, time_interval)
    ode_matrix <- transition_matrix
    # result=deSolve::ode(y = Q, times = times, func = mbd_loglik_rhs, parms = ode_matrix,atol=a_abstol,rtol=a_reltol)[2,-1]
    R.utils::withTimeout(result <- deSolve::ode(y = Q, times = times, func = mbd_loglik_rhs, parms = ode_matrix,atol=a_abstol,rtol=a_reltol)[2,-1], timeout = 1000)
  }

# if ( ( any(!is.numeric(result)) || any(is.nan(result)) ) && methode!="sexpm"){
  #     # to run this you actually need sexpm to be installed which, on the cluster, might not be the case.
  #     exp_matrix = rsexpm:::sexpm(transition_matrix*time_interval)
  #     result = exp_matrix %*% Q
  # }

return(result)
}

This is not to be called by the user.
}
