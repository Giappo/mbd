#' @title are_these_parameters_wrong
#' @description check parameters consistency
#' @inheritParams default_params_doc
#' @export
are_these_parameters_wrong <- function(
 pars,
 safety_threshold,
 N0
)
{
  lambda <- pars[1]
  mu     <- pars[2]
  nu     <- pars[3]
  q      <- pars[4]
  
  if (length(pars) != 4) {
    stop("'pars' must have a length of four")
  }
  if (any(is.nan(pars))) {
    stop("'pars' cannot contain NaNs")
  }
  if (!check_brts_consistency(brts = brts, N0 = N0)) {
    stop("these branching times cannot be generated by a mbd process")
  }
  
  out <- (any(is.infinite(pars))) ||
  (lambda < 0.0) ||
  (mu < 0.0) ||
  (nu < 0.0) ||
  (q < 0.0) ||
  (q > 1.0) ||
  (q < 0 + safety_threshold) ||
  (q > 1.0 - safety_threshold)
    
}

#' Function to build a matrix, used in creating the A and B operators.
#' It produces the structure
#'  q ^ (m - n) * (1 - q) ^ (k + 2 * n-m) *
#'  sum_j 2 ^ j choose(k, j) * choose(n, m - n - j)
#' @inheritParams default_params_doc
#' @examples
#'   m <- hyper_a_hanno(n_species = 2, k = 2, q = 0.1)
#'   testthat::expect_equal(m[1, 1], 0.81)
#'   testthat::expect_equal(m[1, 2], 0.00)
#'   testthat::expect_equal(m[1, 3], 0.00)
#'   testthat::expect_equal(m[2, 1], 0.36)
#'   testthat::expect_equal(m[2, 2], 0.729)
#'   testthat::expect_equal(m[2, 3], 0.00)
#'   testthat::expect_equal(m[3, 1], 0.04)
#'   testthat::expect_equal(m[3, 2], 0.405)
#'   testthat::expect_equal(m[3, 3], 0.6561)
#' @noRd
#' @author Hanno Hildenbrand, adapted by Richel J.C. Bilderbeek
hyper_a_hanno <- function(
  n_species, 
  k, 
  q
) 
{
  if (n_species > 46340) {
    stop(
      "'n_species' must be below 46340. ",
      "Cannot allocate matrix with 2^31 elements"
    )
  }
  # HG function: fast O(N), updated after Moulis meeting
  j <- 0:k
  a_1 <- (1 - q) ^ (k) * choose(k, j) * (2)^j
  n_species <- n_species + 1
  matrix_a <- diag(a_1[1], nrow = n_species + 2, ncol = n_species + 2)
  matrix_a[1:(k + 1), 1] <- a_1
  for (dst in 2:n_species) {
    src <- dst - 1
    s <- src:min(n_species, 2 * src + k - 1)
    matrix_a[s + 2, dst] <- matrix_a[s, src] + matrix_a[s + 1, src]
    m <- s - 1
    n <- src - 1;
    matrix_a[s, src] <- matrix_a[s, src] * q ^ (m - n) * (1 - q) ^ (2 * n - m)
  }
  matrix_a[n_species, n_species] <- matrix_a[n_species, n_species] *
    (1 - q) ^ (n_species - 1);
  matrix_a[1:n_species, 1:n_species]
}

#' @title Internal mbd function
#' @description Internal mbd function.
#' @inheritParams default_params_doc
#' @details This is not to be called by the user.
#' @export
create_a <- function(
  pars,
  k,
  max_number_of_species,
  matrix_builder = mbd:::hyper_a_hanno
) 
{
  lambda <- pars[1]
  mu     <- pars[2]
  nu     <- pars[3]
  q      <- pars[4]
  
  testit::assert(max_number_of_species < 2 ^ 31)
  nvec <- 0:max_number_of_species
  
  m <- nu * matrix_builder(
    n_species = max_number_of_species, 
    k = k, 
    q = q
  )
  diag(m)  <- (-nu) * (1 - (1 - q) ^ (k + nvec)) - (lambda + mu) * (k + nvec)
  m[row(m) == col(m) - 1] <- mu * nvec[2:(max_number_of_species + 1)]
  m[row(m) == col(m) + 1] <- m[row(m) == col(m) + 1] +
                             lambda * (nvec[1:(max_number_of_species)] + 2 * k)
  m[length(nvec), length(nvec)] = (-mu) * (k + nvec[length(nvec)]) +
                                  (-nu) * (1 - (1 - q) ^ (k + nvec[length(nvec)]))
  
  m
}

#' @title Internal mbd function
#' @description Internal mbd function.
#' @inheritParams default_params_doc
#' @details This is not to be called by the user.
#' @export
create_b <- function(
  pars,
  k,
  b,
  max_number_of_species,
  matrix_builder = mbd:::hyper_a_hanno
) 
{
  lambda <- pars[1]
  mu     <- pars[2]
  nu     <- pars[3]
  q      <- pars[4]
  
  k2 <- k - b
  m <- matrix_builder(n_species = max_number_of_species, k = k2, q = q)
  
  lambda * k * diag(max_number_of_species + 1) *
    (b == 1) + nu * choose(k, b) * (q^b) * m
}

#' The A operator is given by the integration of a set of differential equations
#' between two consecutive nodes. So, defined the set in the time interval
#' [t_{i-1}, t_i], where k species are present in the phylogeny, as:
#'
#' d
#' --Q^k_m(t) = SUM_n(M^k_m,n * Q^k_n(t)
#' dt
#'
#' where m, n, label the amount of unseen species in the phylogeny,
#' A is thus defined as:
#'
#' A(t_i - t_{i-1}) = exp(M(t_k - t_{k-1})
#' @inheritParams default_params_doc
#' @noRd
a_operator <- function(
  q_vector,
  transition_matrix,
  time_interval,
  precision = 50L,
  a_abstol = 1e-16,
  a_reltol = 1e-10,
  methode = "expo"
) {
  precision_limit <- 2000
  precision_step1 <- 40
  precision_step2 <- 50
  max_repetitions <- 10
  result <- rep(-1, length(q_vector))
  bad_result <- 0

  testit::assert(methode != "sexpm")
  if (methode == "expo") {
    result_nan <- result_negative <- 1
    repetition <- 1
    while ((result_nan == 1 | result_negative == 1) &
      repetition < max_repetitions
    ) {
      result <- try(
        expoRkit::expv(
          v = q_vector,
          x = transition_matrix,
          t = time_interval,
          m = precision
        ),
        silent = TRUE
      )

      result_nan <- (any(!is.numeric(result)) || any(is.nan(result)))
      if (result_nan) {
        precision <- precision - precision_step1
      } else {
        result_negative <- (any(result < 0))
        if (result_negative) {
          precision <- precision + precision_step2
          if (precision > precision_limit) {
            break
          }
        }
      }
      repetition <- repetition + 1
    }
  }

  bad_result <- (any(!is.numeric(result)) || any(is.nan(result)))
  if (!bad_result) {
    bad_result <- (any(result < 0))
  }

  if (methode == "lsoda" | bad_result) {
    times <- c(0, time_interval)
    ode_matrix <- transition_matrix
    R.utils::withTimeout(result <- deSolve::ode(
      y = q_vector,
      times = times,
      func = mbd_loglik_rhs,
      parms = ode_matrix,
      atol = a_abstol,
      rtol = a_reltol)[2, -1],
      timeout = 1001
    )
  }

  result
}

#' @title Internal mbd function
#' @description Internal mbd function.
#' @inheritParams default_params_doc
#' @details This is not to be called by the user.
#' @export
mbd_loglik_rhs <- function(
  t,
  x,
  pars
) 
{
  #builds right hand side of the ODE set for multiple birth model
  with(as.list(x), {
    starting_vector <- x
    transition_matrix <- pars
    dx <- rep(0, length(starting_vector))
    dx <- drop(transition_matrix %*% starting_vector)
    out <- (dx)
    names(out) <- names(x)
    return(list(out))
  })
}

#' @title Test consistency of branching times
#' @description Test if the given branching times can actually be generated by a MBD process. In any moment you CANNOT have more births than number of species.
#' @inheritParams default_params_doc
#' @return TRUE or FALSE.
#' @export
check_brts_consistency <- function(brts, N0) {
  births <- brts2time_intervals_and_births(brts)$births
  kvec <- N0 + cumsum(c(0, births)); kvec
  all(births <= kvec[-length(kvec)])  
}

#' @title Internal mbd function
#' @description Internal mbd function.
#' @inheritParams default_params_doc
#' @details This is not to be called by the user.
#' @export
alpha_analysis <- function(
  brts,
  pars,
  tips_interval,
  cond,
  soc,
  alpha0,
  max_k,
  methode = "expo",
  abstol,
  reltol,
  minimum_multiple_births
) {
  delta_alpha <- 1
  count <- 0
  same_result_count <- 0
  pc_notanumber <- 1
  alpha <- alpha0
  while (pc_notanumber) {
    pc_1 <- mbd_calc_alpha_cond_prob(
      brts = brts,
      pars = pars,
      tips_interval = tips_interval,
      cond = cond,
      soc = soc,
      alpha = alpha,
      methode = methode,
      abstol = abstol,
      reltol = reltol,
      minimum_multiple_births = minimum_multiple_births
    )$pc
    pc_notanumber <- is.nan(pc_1)
    alpha <- alpha - pc_notanumber
  }
  while (delta_alpha != 0 && count < 100 && same_result_count < 5) {
    pc_2 <- mbd_calc_alpha_cond_prob(
      brts = brts,
      pars = pars,
      tips_interval = tips_interval,
      cond = cond,
      soc = soc,
      alpha = alpha + delta_alpha,
      methode = methode,
      abstol = abstol,
      reltol = reltol,
      minimum_multiple_births = minimum_multiple_births
    )$pc
    if (is.nan(pc_2)) {
      delta_alpha <- delta_alpha - 1
    } else if (pc_2 < pc_1) {
      delta_alpha <- delta_alpha + 1
      same_result_count <- same_result_count + 1
    } else {
      same_result_count <- 0
      delta_pc <- abs(pc_2 - pc_1) / pc_1;
      delta_alpha <- floor(10 * delta_pc)
      alpha <- alpha + delta_alpha
      pc_1 <- pc_2
    }
    
    count <- count + 1
  }
  if (max_k * alpha >= 2000) {
    #check to see whether alpha is too big to be handled without memory issues
    alpha <- floor(1500 / max_k)
    pc_1 <- mbd_calc_alpha_cond_prob(
      brts = brts,
      pars = pars,
      tips_interval = tips_interval,
      cond = cond,
      soc = soc,
      alpha = alpha,
      methode = methode,
      abstol = abstol,
      reltol = reltol,
      minimum_multiple_births = minimum_multiple_births
    )$pc
  }
  pc <- pc_1
  if (count >= 100) {
    alpha <- 10
  }
  if (pc <= 0 | pc == Inf | pc == -Inf) {
    pc <- 1
    print("there's a problem with pc")
  }
  return(list(pc = pc, alpha = alpha))
}

#' Converts branching times to "time intervals between branching times"
#'   and "birth at nodes" vectors
#' @inheritParams default_params_doc
#' @noRd
brts2time_intervals_and_births <- function(
  brts
) {
  time_points <- -unlist(unname(sort(abs(brts), decreasing = TRUE)))
  branching_times <- -sort(abs(as.numeric(time_points)), decreasing = TRUE)
  births <- c(0, unname(table(branching_times))[-1])
  unique_branching_times <- as.numeric(names(table(branching_times)))
  time_intervals <- c(
    diff(unique_branching_times),
    abs(utils::tail(unique_branching_times, 1))
  )
  births <- births[-1]
  list(time_intervals = time_intervals, births = births)
}